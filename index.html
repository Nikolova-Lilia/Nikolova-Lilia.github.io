<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Lilia Nikolova — Interactive Portfolio</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header class="wrap">
    <h1 class="title">Lilia Nenkova Nikolova</h1>
    <p class="subtitle">Software Developer Student @ 42 Prague</p>
    <nav class="btns">
      <a class="btn" href="lilia_nikolova_cv.pdf" download>Download CV (PDF)</a>
      <a class="btn" href="https://www.linkedin.com/in/lilia-nikolova-747845201/" target="_blank" rel="noopener">LinkedIn</a>
      <a class="btn" href="https://github.com/Nikolova-Lilia" target="_blank" rel="noopener">GitHub</a>
    </nav>
  </header>

  <main class="wrap">
    <section class="showcase">
      <div class="copy">
        <h2>Interactive 3D Preview</h2>
        <p>Hover and move your mouse to rotate the forest‑green cube. This is your Three.js demo embedded directly inside the card.</p>
        <p><small>Built with Three.js.</small></p>
      </div>
      <div class="canvas-wrap">
        <div id="cube-app" class="cube-app" aria-label="3D scene" tabindex="0"></div>
        <div class="hint">Hover & move to rotate</div>
      </div>
    </section>

    <section class="cards">
      <h2>Projects</h2>
      <div class="grid">
        <article class="card">
          <h3>Docker & Web Server (School)</h3>
          <p>Building containers and a minimal web server; focus on networking, security, and deployment.</p>
        </article>
        <article class="card">
          <h3>Exam / Training Platform (Side)</h3>
          <p>A platform for practicing and assessing programming skills with version-controlled content.</p>
        </article>
        <article class="card">
          <h3>Upcoming: Diabetes Calendar</h3>
          <p>Personal health tracker concept focusing on clarity and daily usability.</p>
        </article>
        <article class="card">
          <h3>Upcoming: Skyscraper 3D Visualization</h3>
          <p>Exploring geometry generation and interaction patterns for architectural visualization.</p>
        </article>
      </div>
    </section>
  </main>

  <footer class="wrap center">
    <small>© <span id="year"></span> Lilia Nikolova</small>
  </footer>

  <!-- Use your module-based Three.js cube, adapted to fit inside #cube-app -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';

    // Container inside the card
    const app = document.getElementById('cube-app');

    const scene = new THREE.Scene();
    // A soft background; card provides light gray; keep scene transparent
    // scene.background = new THREE.Color(0xf8f8f8);

    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
    camera.position.set(0, 1.2, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    // --- lighting ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const key = new THREE.DirectionalLight(0xffffff, 1.0);
    key.position.set(3, 5, 4);
    key.castShadow = true;
    key.shadow.mapSize.set(1024, 1024);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0x88ff88, 0.25);
    rim.position.set(-3, 2, -4);
    scene.add(rim);

    // --- floor for soft shadow ---
    const floorGeo = new THREE.PlaneGeometry(50, 50);
    const floorMat = new THREE.ShadowMaterial({ opacity: 0.18 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -1.2;
    floor.receiveShadow = true;
    scene.add(floor);

    // --- the cube (forest dark green) ---
    const cubeGeo = new THREE.BoxGeometry(2, 2, 2);
    const cubeMat = new THREE.MeshStandardMaterial({
      color: 0x0b3d0b, // forest dark green
      roughness: 0.6,
      metalness: 0.05,
      envMapIntensity: 0.6,
    });
    const cube = new THREE.Mesh(cubeGeo, cubeMat);
    cube.castShadow = true;
    scene.add(cube);

    // --- small environment boxes (optional subtle reflections) ---
    const group = new THREE.Group();
    for (let i = 0; i < 9; i++) {
      const g = new THREE.BoxGeometry(0.2, 0.2, 0.2);
      const m = new THREE.MeshStandardMaterial({ color: 0x163b16, roughness: 0.9, metalness: 0.0 });
      const s = new THREE.Mesh(g, m);
      s.position.set((Math.random()-0.5)*10, Math.random()*2-0.5, (Math.random()-0.5)*10);
      s.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
      group.add(s);
    }
    scene.add(group);

    // --- interaction & inertia ---
    let hovering = false;
    let prev = { x: 0, y: 0 };
    let velocity = { x: 0, y: 0 };

    app.addEventListener('mouseenter', () => { hovering = true; app.style.cursor = 'grab'; });
    app.addEventListener('mouseleave', () => { hovering = false; app.style.cursor = 'default'; });
    app.addEventListener('mousemove', (e) => {
      if (!hovering) return;
      const rect = app.getBoundingClientRect();
      const dx = e.clientX - prev.x;
      const dy = e.clientY - prev.y;
      velocity.x = THREE.MathUtils.clamp(dx * 0.002, -0.05, 0.05);
      velocity.y = THREE.MathUtils.clamp(dy * 0.002, -0.05, 0.05);
      prev.x = e.clientX; prev.y = e.clientY;
    }, { passive: true });

    window.addEventListener('mousemove', (e) => { prev.x = e.clientX; prev.y = e.clientY; }, { passive: true });

    // --- fit to container ---
    function resize(){
      const w = app.clientWidth || 600;
      const h = app.clientHeight || 400;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    const ro = new ResizeObserver(resize);
    ro.observe(app);
    window.addEventListener('resize', resize);
    resize();

    // --- animate ---
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      cube.rotation.y += velocity.x;
      cube.rotation.x += velocity.y;
      velocity.x *= 0.92;
      velocity.y *= 0.92;
      const t = clock.getElapsedTime();
      if (!hovering) {
        cube.rotation.y += 0.0015;
        cube.rotation.x += Math.sin(t * 0.6) * 0.0004;
      }
      renderer.render(scene, camera);
    }
    animate();

    document.getElementById('year').textContent = new Date().getFullYear();
  </script>
</body>
</html>
